<스크립트 파일 간 데이터 송수신>

[송신]
chrome.runtime.sendMessage({
            action: "selectedText",
            data: selectedText
            key: value
        });

[수신]
chrome.runtime.onMessage.addListener(
    function(request, sender, sendResponse) {
    request.action
    request.data
    request.key             <- 데이터 접근 가능
});


//이벤트 등록
document.addEventListener('이벤트 종류', 등록할 함수명);

<로그작성법>
console.log('로그 내용 입력')


[단축평가]
//&&는 앞의 값이 true인지 false인지 판별하고 B의 반환 여부를 결정함. A가 true로 판별되어야 B가 결과가 된다. B를 반환하지 않는다면 A(false)를 반환함.
var result = (A) && (B)
-> A가 false인 경우 and연산자의 결과는 true가 될 수 없음이 자명하다. 따라서 B의 확인을 멈추고 A에서 스캔이 끝난다. 따라서 결과는 false인 A가 된다. 
반대로 A가 true라면 B를 읽어야 and의 결과를 알 수 있다. 하지만 B가 true든 false든 B에 도달한 시점에서 &&연산자의 결과는 B가 된다. (B를 읽고있는 중이므로)
따라서 A와 B의 and연산이 목적이 아닌, A의 true/false여부를 확인하는 것이 목적이다. 


//||는 앞의 값이 false인 경우 B를 반환함.  
var result = (A) || (B)

-> 결론은 if문 압축한거. 다만 else를 빠르게 지정할 수 있다.

단축평가-> 평가가 특정 시점에서 완료될 수 있다면 그 시점에서 값이 확정된다. and 비교는 앞, 뒤의 값을 통해 판단하는데, 판단을 위해 읽는 마지막 값이 뒤의 값이므로 결과는 뒤의 값이된다
반대로 or연산은 앞의 값으로 1차적인 판단이 가능하므로 앞에서 판단이 멈춘다. 따라서 앞의 값이 결과가 된다. 앞에서 멈추지 않는다면 다음은 무조건 뒤의 값을 읽어야하므로 결과가 뒤의 값이 된다.

[익명함수]
function A() {};

var A = function() {}; <- 리터럴 방식을 사용한 익명함수
// js는 모든 함수를 호이스팅함. 변수에 선언된 함수는 호이스팅되지 않음. 또한 변수선언 함수는 재사용성이 없다.

var A = function a() {}; <- 익명함수를 기명함수로 선언함. 기능상으로 차이는 없으나 디버그할때 구분 쉽다.


[객체리터럴]
var car = { manyCars: {a: "Saab", "b": "Jeep"}, 7: "Mazda" };

console.log(car.manyCars.b); // Jeep
console.log(car[7]); // Mazda

key : value를 지정하고 변수로부터 .표기를 통해 값에 접근할 수 있다.

[즉시실행함수]
(function a(x) {
    "내용"
})(x에 들어갈 값);

(function (x) {
    "내용"
})(x에 들어갈 값);

실행시에 1번 조건 없이 즉시 실행되는 함수. 함수를 괄호에 집어넣고 괄호를 한번 더 사용하는데, 이 괄호 안에 인자에 들어갈 값을 작성할 수 있다.(다른 코드에서 지정할 수 없으므로)

[변수의 $의미]
원래는 jquery 객체를 다른 변수와 구별하는것이 목적이지만 그 외에 사용하는 요인은 해당 변수의 유일성을 의미한다.

[실행 컨텍스트]
개발자가 작성한 코드가 실행되는 전반적인 환경

글로벌 실행 컨텍스트: 코드가 실행되기 전 함수 내에서 작성되지 않은 코드는 전역 실행 컨텍스트 영역에 존재하게된다.
무조건 하나의 전역 실행 컨텍스트만이 존재하며, 애플리케이션이 종료될 때까지 유지된다.

함수 실행 컨텍스트: 전역 실행 컨텍스트 생성 이후 함수가 실행되는 타이밍에 작성되는 실행 컨텍스트이다.

[스코프 체인]
실행 컨텍스트는 선입후출구조 스택임. 실행 컨텍스트는 코드 실행 중 생성된 모든 실행 컨텍스트를 저장하는데 사용한다.
실행 컨텍스트가 실행될 때, 엔진은 스코프체인을 이용하여 렉시컬 스코프체인을 먼저 파악한다. 그리고 나서 함수가 중첩되었다면 하위 함수 내에서 상위 함수의 스코프, 전역 스코프를 참조할 수 있는데,
이것을 스코프체인을 통해 탐색한다. 따라서 스코프 체인은 참조 가능한 스코프끼리의 연결 관계를 의미한다.

var v = "전역 변수";

function a() {
//function a Execution Context(EC)
	var v = "지역 변수";
    
    function b() {
    	//function b Execution Context
    	console.log(v);
    }
    b();
}
//Global Execution Context
a();

라는 코드에서, 글로벌 실행 컨텍스트 실행 -> fn a()를 스택에 쌓는다. -> fn b()를 스택에 쌓는다. -> b()에서 v를 호출하는 코드를 발견했다 ->
b()내부에서 v의 선언을 찾는다 -> 그다음 스택인 a()를 탐색한다. -> 그다음 스택인 글로벌 실행 컨텍스트를 실행한다.

따라서, 자기 자신의 스코프를 제외한 자신과 가장 가까운 변수 객체는 스코프 체인이된다. (자기 자신이 실행되기 이전 역순으로 탐색하므로)
반대로, LIFO의 구조 탓에 역으로 접근하는건 불가능하다. b에서 a로 탐색을 하지만, 만약 b안에 c가 선언되는 경우 b에서 c를 탐색할 수 없다. 왜냐하면 b기준으로 c는 나중에 쌓이는 스택이며, b보다 먼저 나가기 때문이다.

함수레벨 스코프: 안에서 바깥을 참조하는 것은 가능하지만 전역에서 스코프 내부를 참조할 수 없다.
var 선언의 경우 함수 내부만을 스코프로 인정한다. 함수 내에 if문으로 블록이 나누어지고, 이 내부에 선언이 되어있더라도, 함수 안이라면 자유롭게 접근 가능하다.
let, const는 블록레벨 스코프이다. if와 같은 { }를 사용해 영역을 구분했다면 { }외부에서 내부를 접근할 수 없다.


[렉시컬 스코프]
스태틱 스코프라고도 한다. 함수의 선언 위치에 따라 상위 스코프를 결정한다. 함수의 호출 위치는 그 위치의 상위 스코프를 무시한다.
a,b함수가 있고 a함수 내에 b함수가 호출될 때, a의 스코프와 b의 스코프는 체인되지 않는다.
하지만 a함수 내에 b함수가 선언되었다면, b의 스코프는 a스코프에 체인된다. 선언과 호출의 차이이다.


[클로저]
함수 안에 함수를 선언한 환경에서, 내부 함수는 외부함수의 변수에 접근할 수 있는데, 외부함수가 소멸 된 이후에도 내부함수가 외부함수의 변수에 접근할 수 있는것을 클로저라고 한다.
함수를 리턴할 때 리턴되는 함수는 클로저를 형성한다. 클로저는 반환된 내부함수가 자신이 선언되었을 때의 환경에서의 스코프를 기억하기 때문에 접근이 가능하다.

function outerFunc() {
  // 외부 함수의 변수
  var x = 10;

  // 내부 함수에서 외부 함수의 변수에 접근할 수 있습니다.
  var innerFunc = function () {
    console.log(x);
  };

  return innerFunc; <- outerFunc()를 종료하고 innerFunc 호출
}

var inner = outerFunc();
inner(); // 10

innerFunc를 호출하기는 했지만 이 시점에서 outerFunc는 종료되었기에 x에 접근할 수 없으나, 클로저가 innerFunc가 선언된 outerFunc 내부의 스코프를 저장하고 있기에 데이터에 접근 가능하다.
외부 함수 스코프 내의 객체는 활성객체 상태로, 내부함수에 의해 참조되는 한 유효하며, 스코프체인을 통해 접근할 수 있다.

[일급객체]
변수에 할당하거나, 인자로 받거나, 리턴할 수 있는 함수를 의미함

[고차함수]
함수를 전달인자, 매개변수로 받거나 함수를 리턴하는 함수

[콜백 함수]
매개변수로 객체를 전달받아 함수 내에서 매개변수 함수를 실행한다. 
익명함수: 함수의 매개변수 위치에서 직접 익명으로 함수를 작성할 수도 있다.
=>: 익명함수를 더욱 간결하게 작성한 형태. 

function sayHello(callback) {
  var name = "Alice";
  callback(name); // 콜백 함수 호출
}

// 익명 화살표 콜백 함수
sayHello((name) => {
  console.log("Hello, " + name);
}); // Hello, Alice

콜백 함수를 사용하면 이전과 다르게 호출시에 작성하는 코드가 많아진다. 이벤트 함수도 호출할때 바로 기능을 작성할 수 있는데 그럴때 씀

[객체 리터럴]
프로퍼티를 이용해 정의한 함수이다.
A: function() {}
자바스크립트에서 객체는 다양한 타입의 데이터를 한 단위로 묶은 복합 데이터 구조를 말하며,
이 객체 내부에서 함수를 지정할 때 주로 사용된다. 접근 방법은 객체.리터럴 함수()로 접근한다.


[모듈 디자인 패턴]
자바스크립트에서 구현하는 객체지향적 구조이다. 코드 단위를 명확하게 분리하여 구현하는게 목적이다.
사실상 클로저를 기반으로 작동하는 코드이다. 

var Counter = (function () { //즉시실행함수로 감싼다
  // private 변수
  var num = 0;

  // 클로저
  //외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다.
    return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    }
  };
}());

익명 함수를 즉시실행 함수로 작성하였다. 외부의 코드로 Counter내부의 변수에 접근하는 것은 불가능하다. 캡슐화되어있다.
즉시실행함수는 한번만 실행되므로 Counter을 여러번 호출하여도 변수가 초기화되지 않는다.
클로저는 즉시실행함수의 렉시컬 스코프를 기억한다. 따라서 num을 유지시킨다.


[클로저의 응용]
클로저란 이미 실행이 종료된 함수의 변수나 함수를 참조할 수 있는 링크를 가진 내부함수를 말한다.
클로저의 핵심은 스코프를 이용하여, 변수의 접근범위를 제한하는데에 있다.
변수의 선언 위치에 따라서 클로저가 지정되므로 위치를 잘 생각해야함.
외부함수보다 중첩된 하위 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명주기가 종료된 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라고 한다.
클로저는 상태가 의도치 않게 변경되지 않도록 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하여 상태를 안전하게 변경하고 유지하기 위해 사용된다. 이는 모듈 패턴을 구현하는데에 사용할 수 있다.





[즉시실행함수 응용]
즉시실행함수는 정의되는 동시에 실행된다. 선언 호출을 한번에 하는 함수이며, 단 한번만 실행된다.
즉시실행함수를 사용하는 이유는 전역변수의 사용을 줄이는데 있다. 상태가 변경되기 좋고, 리소스도 장시간 차지한다. 또한 스코프체인의 종점이기에 변수 검색도 느리다.
자바 스크립트는 파일을 분리해도 하나의 전역 스코프를 공유한다. 따라서 전역변수는 배제하는 편이 좋다.
즉시실행함수로 감싼 모든 변수는 전역변수가 아닌 즉시실행함수의 지역변수가 된다. 이를 통해 모듈패턴 개발을 한다.


<상속>
[생성자]
JS에서는 함수는 코드를 재사용하기 위해서 사용하거나, 객체를 생성하기 위해 사용한다.
객체를 생성할 때, new키워드를 사용하여 함수를 호출하면 리턴문 없이 새로운 객체를 반환시킨다.

function Teacher(name, age, subject) {
  this.name = name
  this.age = age
  this.subject = subject
  this.teach = function (student) {
    console.log(`${student}에게 ${this.subject}를 가르칩니다`)
  }
}
const jay = new Teacher("jay", 30, "javascript")

생성자의 기본 구조이다. new 키워드는 return 없이 Teacher함수를 복제하였다. 곧 jay는 인스턴스이다.
반환해야 하는 요소들은 this에 저장된다. this는 자동으로 반환되므로 반환문이 필요없다.

[this]
JS에서 생성자에 한해 this는 new 연산자를 통해 생성된 인스턴스를 가리킨다.
 Teacher에서 선언없이 this.name부터 작성되어있지만 인스턴스인 jay에 프로퍼티를 생성하고, 인자를 값으로 만든다.
이 경우 new연산자를 사용하지 않으면 일반적인 this의 기능을 한다.

[생성자의 처리]
new Teacher을 사용하면 this라는 빈 객체를 만든다. 이후 함수 본문을 실행해 this에  프로퍼티를 추가하고 this를 return 한다.
원래의 함수에 사용된 this.변수 = 인자; 를 전부 this 객체에 집어넣는다. 이후 return this를 암시적으로 실행한다.
따라서 인스턴스에 초기화된 값이 곧바로 삽입된다.

[prototype]
생성된 함수는 암시적인 prototype속성이 생성되고 함수의 프로토타입 객체를 참조한다.
이 프로토타입 객체는 new 연상자, person 함수를 통해 생성된 모든 객체의 원형이된다. 생성된 모든 객체가 참조한다. 모든 인스턴스 객체는 __proto__ 라는 숨겨진 속성을 통해 프로토타입 객체에 링크된다.

[prototype 접근]
어떠한 원형 함수를 생성하고, 이에 대한 인스턴스를 생성한 이후 (원형 함수).prototype을 통해 원형 함수의 프로토타입 객체에 접근할 수 있다.
prototype객체는 모든 인스턴스에 링크되므로 어느 시점에 수정하든 반영된다. 
자바스크립트에서 기본 데이터 타입을 제외한 모든것은 객체이다. 객체가 만들어질 때 자신에 대한 원형인 프로토타입 객체를 이용하여 객체를 만든다.
이때 만들어진 객체안에는 __proto__ 이라는 숨겨진 속성이 존재하고 이 속성을 통해 원본 객체의 프로토타입에 접근할 수 있다.
이 프로토타입 링크를 사용하여 객체 지향적인 프로그래밍을 한다.

[코드의 재사용 = 상속]
자바스크립트는 클래스라는 개념이 없는 프로토타입 기반 언어이다. 따라서 프로토타입의 방식을 통해 상속을 구현한다.
JS에서 상속은 new연산자를 사용한 classical 방식과 Object.create()를 사용하는 prototypal 방식 2가지가 있다.

부모함수를 생성하고, 부모함수의 프로토타입 접근을 통해 함수, 요소를 추가한다. 이후 자식 함수로 할 함수를 생성한 뒤 자식 함수의 prototype에 부모함수를 new연산자로 삽입한다.
이러면 부모함수에서 제공하는 인스턴스를 수정하며, 수정된 인스턴스를 자식에게 넘겨줄 수 있다. 자식의 인스턴스가 부모의 인스턴스이므로 이후 자식의 인스턴스는 수정된 부모의 인스턴스가 된다.
다만 이렇게 프로토타입을 복제하는 방식으로 물려주는 경우 부모 함수에 지정된 인자 기능을 전달할 수는 없다.

[생성자 빌려쓰기]
부모 함수의 this에 자식 객체를 바인딩하는 방법이 있다.

function 자식(부모 인자) { 부모.apply(this, arguments); }
apply 함수는 암시적 함수로, 부모의 this를 바인딩하여 속성을 복사할 수 있다.
기존의 방법과 다르게 부모의 this로 지정한 멤버만을 불러온다. 또란 다른 프로토타입 객체, 수정된 프로토타입 내용은 불러올 수 없다. 여기서 프로토타입을 한번더 불러올 수는 있으나 비효율적이다.

[프로토타입 공유]
부모.prototype = 자식.prototype;
그냥 참조시켜도 된다.

[prototypal 방식 상속]
var 자식 = Object.create(부모);
매개변수로 부모객체를 지정할 수 있고, 두번째 매개변수로 자식의 속성 추가가 가능하다.

[window 객체]
브라우저 안의 모든 요소들을 한데 모은 최상위 객체이다. 스크립트에서 작성하는 모든 코드는 window 객체의 프로퍼티이다.
스크립트에서 함수를 생성하였을 때, window.함수() 라고 호출할 수도 있다. 

[this 바인딩]
this는 특정 스코프 내의 요소에 바인딩된 특수 예약어이다. 전역 객체는 window이므로 전역 위치의 this===window이다.
함수에서 사용하는 경우 함수 호출시 this는 함수를 호출한 위치를 기준으로 바인딩된다.
=>로 선언된 익명 함수는 this를 가지지 않는 객체이다. 그리고 한칸 위의 스코프에 바인딩된다.

[apply]
apply 함수는 함수를 호출하면서, this의 값, 인수를 바인딩할 수 있는 메소드이다.